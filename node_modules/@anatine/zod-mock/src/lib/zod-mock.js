"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateMock = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const faker_1 = require("@faker-js/faker");
const randExp = require("randexp");
function parseObject(zodRef, options, depth) {
    return Object.keys(zodRef.shape).reduce((carry, key) => (Object.assign(Object.assign({}, carry), { [key]: generateMock(zodRef.shape[key], Object.assign(Object.assign({}, options), { keyName: key }), depth + 1) })), {});
}
function parseRecord(zodRef, options, depth) {
    const recordKeysLength = (options === null || options === void 0 ? void 0 : options.recordKeysLength) || 1;
    return new Array(recordKeysLength).fill(null).reduce((prev) => {
        return Object.assign(Object.assign({}, prev), { [generateMock(zodRef.keySchema, options, depth + 1)]: generateMock(zodRef.valueSchema, options, depth + 1) });
    }, {});
}
function findMatchingFaker(keyName) {
    const lowerCaseKeyName = keyName.toLowerCase();
    const withoutDashesUnderscores = lowerCaseKeyName.replace(/_|-/g, '');
    let fnName = undefined;
    const sectionName = Object.keys(faker_1.faker).find((sectionKey) => {
        return Object.keys(faker_1.faker[sectionKey] || {}).find((fnKey) => {
            var _a;
            const lower = fnKey.toLowerCase();
            fnName =
                lower === lowerCaseKeyName || lower === withoutDashesUnderscores
                    ? keyName
                    : undefined;
            // Skipping depreciated items
            const depreciated = {
                random: [
                    'image',
                    'number',
                    'float',
                    'uuid',
                    'boolean',
                    'hexaDecimal',
                ],
            };
            if (Object.keys(depreciated).find((key) => key === sectionKey
                ? depreciated[key].find((fn) => fn === fnName)
                : false)) {
                return undefined;
            }
            if (fnName) {
                // TODO: it would be good to clean up these type castings
                const fn = (_a = faker_1.faker[sectionKey]) === null || _a === void 0 ? void 0 : _a[fnName];
                if (typeof fn === 'function') {
                    try {
                        // some Faker functions, such as `faker.mersenne.seed`, are known to throw errors if called
                        // with incorrect parameters
                        const mock = fn();
                        return typeof mock === 'string' ||
                            typeof mock === 'number' ||
                            typeof mock === 'boolean' ||
                            mock instanceof Date
                            ? fnName
                            : undefined;
                    }
                    catch (_error) {
                        // do nothing. undefined will be returned eventually.
                    }
                }
            }
            return undefined;
        });
    });
    if (sectionName && fnName) {
        const section = faker_1.faker[sectionName];
        return section ? section[fnName] : undefined;
    }
}
function parseString(zodRef, options) {
    var _a;
    const { checks = [] } = zodRef._def;
    const regexCheck = checks.find((check) => check.kind === 'regex');
    if (regexCheck && 'regex' in regexCheck) {
        const generator = new randExp(regexCheck.regex);
        const max = checks.find((check) => check.kind === 'max');
        if (max && 'value' in max && typeof max.value === 'number') {
            generator.max = max.value;
        }
        const genRegString = generator.gen();
        return genRegString;
    }
    const lowerCaseKeyName = (_a = options === null || options === void 0 ? void 0 : options.keyName) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    // Prioritize user provided generators.
    if ((options === null || options === void 0 ? void 0 : options.keyName) && options.stringMap) {
        // min/max length handling is not applied here
        const generator = options.stringMap[options.keyName];
        if (generator) {
            return generator();
        }
    }
    const stringOptions = {};
    checks.forEach((item) => {
        switch (item.kind) {
            case 'min':
                stringOptions.min = item.value;
                break;
            case 'max':
                stringOptions.max = item.value;
                break;
        }
    });
    const sortedStringOptions = Object.assign({}, stringOptions);
    // avoid Max {Max} should be greater than min {Min}
    if (sortedStringOptions.min &&
        sortedStringOptions.max &&
        sortedStringOptions.min > sortedStringOptions.max) {
        const temp = sortedStringOptions.min;
        sortedStringOptions.min = sortedStringOptions.max;
        sortedStringOptions.max = temp;
    }
    const targetStringLength = faker_1.faker.datatype.number(sortedStringOptions);
    /**
     * Returns a random lorem word using `faker.lorem.word(length)`.
     * This method can return undefined for large word lengths. If undefined is returned
     * when specifying a large word length, will return `faker.lorem.word()` instead.
     */
    const defaultGenerator = () => faker_1.faker.lorem.word(targetStringLength) || faker_1.faker.lorem.word();
    const dateGenerator = () => faker_1.faker.date.recent().toISOString();
    const stringGenerators = {
        default: defaultGenerator,
        email: faker_1.faker.internet.exampleEmail,
        uuid: faker_1.faker.datatype.uuid,
        uid: faker_1.faker.datatype.uuid,
        url: faker_1.faker.internet.url,
        name: faker_1.faker.name.findName,
        date: dateGenerator,
        dateTime: dateGenerator,
        colorHex: faker_1.faker.internet.color,
        color: faker_1.faker.internet.color,
        backgroundColor: faker_1.faker.internet.color,
        textShadow: faker_1.faker.internet.color,
        textColor: faker_1.faker.internet.color,
        textDecorationColor: faker_1.faker.internet.color,
        borderColor: faker_1.faker.internet.color,
        borderTopColor: faker_1.faker.internet.color,
        borderRightColor: faker_1.faker.internet.color,
        borderBottomColor: faker_1.faker.internet.color,
        borderLeftColor: faker_1.faker.internet.color,
        borderBlockStartColor: faker_1.faker.internet.color,
        borderBlockEndColor: faker_1.faker.internet.color,
        borderInlineStartColor: faker_1.faker.internet.color,
        borderInlineEndColor: faker_1.faker.internet.color,
        columnRuleColor: faker_1.faker.internet.color,
        outlineColor: faker_1.faker.internet.color,
        phoneNumber: faker_1.faker.phone.number,
    };
    const stringType = Object.keys(stringGenerators).find((genKey) => genKey.toLowerCase() === lowerCaseKeyName ||
        checks.find((item) => item.kind === genKey)) || null;
    let generator = defaultGenerator;
    if (stringType) {
        generator = stringGenerators[stringType];
    }
    else {
        const foundFaker = (options === null || options === void 0 ? void 0 : options.keyName)
            ? findMatchingFaker(options === null || options === void 0 ? void 0 : options.keyName)
            : undefined;
        if (foundFaker) {
            generator = foundFaker;
        }
    }
    // it's possible for a zod schema to be defined with a
    // min that is greater than the max. While that schema
    // will never parse without producing errors, we will prioritize
    // the max value because exceeding it represents a potential security
    // vulnerability (buffer overflows).
    let val = generator().toString();
    const delta = targetStringLength - val.length;
    if (stringOptions.min != null && val.length < stringOptions.min) {
        val = val + faker_1.faker.random.alpha(delta);
    }
    return val.slice(0, stringOptions.max);
}
function parseNumber(zodRef) {
    const { checks = [] } = zodRef._def;
    const options = {};
    checks.forEach((item) => {
        switch (item.kind) {
            case 'int':
                break;
            case 'min':
                options.min = item.value;
                break;
            case 'max':
                options.max = item.value;
                break;
        }
    });
    return faker_1.faker.datatype.number(options);
}
function parseOptional(zodRef, options) {
    return generateMock(zodRef.unwrap(), options);
}
function parseArray(zodRef, options, depth) {
    var _a, _b;
    let min = ((_a = zodRef._def.minLength) === null || _a === void 0 ? void 0 : _a.value) != null ? zodRef._def.minLength.value : 1;
    const max = ((_b = zodRef._def.maxLength) === null || _b === void 0 ? void 0 : _b.value) != null ? zodRef._def.maxLength.value : 5;
    // prevents arrays from exceeding the max regardless of the min.
    if (min > max) {
        min = max;
    }
    const targetLength = faker_1.faker.datatype.number({ min, max });
    const results = [];
    for (let index = 0; index < targetLength; index++) {
        results.push(generateMock(zodRef._def.type, options, depth + 1));
    }
    return results;
}
function parseEnum(zodRef) {
    const values = zodRef._def.values;
    const pick = Math.floor(Math.random() * values.length);
    return values[pick];
}
function parseNativeEnum(zodRef) {
    const { values } = zodRef._def;
    const pick = Math.floor(Math.random() * (Object.values(values).length));
    const key = Array.from(Object.keys(values))[pick];
    return values[values[key]];
}
function parseLiteral(zodRef) {
    return zodRef._def.value;
}
function parseTransform(zodRef, options) {
    const input = generateMock(zodRef._def.schema, options);
    const effect = zodRef._def.effect.type === 'transform'
        ? zodRef._def.effect
        : { transform: () => input };
    return effect.transform(input, { addIssue: () => undefined, path: [] }); // TODO : Discover if context is necessary here
}
function parseUnion(zodRef, options) {
    // Map the options to various possible mock values
    const mockOptions = zodRef._def.options.map((option) => generateMock(option, options));
    return faker_1.faker.helpers.arrayElement(mockOptions);
}
const workerMap = {
    ZodObject: parseObject,
    ZodRecord: parseRecord,
    ZodString: parseString,
    ZodNumber: parseNumber,
    ZodBigInt: parseNumber,
    ZodBoolean: () => faker_1.faker.datatype.boolean(),
    ZodDate: () => faker_1.faker.date.soon(),
    ZodOptional: parseOptional,
    ZodNullable: parseOptional,
    ZodArray: parseArray,
    ZodEnum: parseEnum,
    ZodNativeEnum: parseNativeEnum,
    ZodLiteral: parseLiteral,
    ZodTransformer: parseTransform,
    ZodEffects: parseTransform,
    ZodUnion: parseUnion,
};

function generateMock(zodRef, options, depth = 0) {
    var _a;
    try {
        const typeName = zodRef._def.typeName;
        const isLazy = typeName === "ZodLazy"
        const ref = isLazy ? zodRef._def.getter() : zodRef;
        const _typeName = isLazy ? ref._def.typeName : typeName;
        if (depth > 3) return null; 
        if (_typeName in workerMap) {
            return workerMap[_typeName](ref, options, depth);
        }
        else {
            // check for a generator match in the options.
            // workaround for unimplemented Zod types
            const generator = (_a = options === null || options === void 0 ? void 0 : options.backupMocks) === null || _a === void 0 ? void 0 : _a[_typeName];
            if (generator) {
                return generator();
            }
        }
        return undefined;
    }
    catch (err) {
        console.error(err);
        return undefined;
    }
}
exports.generateMock = generateMock;
//# sourceMappingURL=zod-mock.js.map